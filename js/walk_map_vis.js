class WalkMapVis {
    constructor(_parentElement, _data, _geoData, _squirrelHectareData, _squirrelMin, _squirrelMax) {
        this.parentElement = _parentElement;
        this.data = _data;
        this.geoHectareData = _geoData;
        this.squirrelDataByHectare = _squirrelHectareData;
        this.squirrelMin = _squirrelMin;
        this.squirrelMax = _squirrelMax;
        this.hectareData = _data[1];
        this.walkLatLngs = [];
        this.hectaresOnWalk = [];

        this.initVis();
    }

    initVis() {
        let vis = this;

        // define map at center of Central Park
        vis.map = L.map('walk_map_vis',{
            zoomSnap: 0.25
        }).setView([40.7812,-73.9665],14.25);

        // add OpenStreetMap Mapnik
        L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(vis.map);

        // FeatureGroup is to store editable layers (layers that are drawn onto map)
        vis.drawnItems = new L.FeatureGroup();
        // add layer to map
        vis.map.addLayer(vis.drawnItems);
        vis.drawControl = new L.Control.Draw({
            // disabling extraneous drawing in order to focus users on their walk path
            draw: {
                polygon: false,
                marker: false,
                circle: false,
                rectangle: false,
                polyline: {
                    shapeOptions: {
                        color: '#281b1b',
                        weight: 4,
                        opacity: 0.9
                    }
                },
            },
            edit: {
                // specifies layer for drawn features
                featureGroup: vis.drawnItems
            }
        });
        // add drawing toolbar to map
        vis.map.addControl(vis.drawControl);


        // when user clicks "Finish" after drawing line, calls following function:
        vis.map.on(L.Draw.Event.CREATED, (event) => {
            let layer = event.layer;
            // console.log(event)

            // extract coordinates of path
            let layerCoords = layer.getLatLngs()
            // console.log(layerCoords)

            // Add layer to map
            vis.drawnItems.addLayer(layer);

            // CALL INFO BOX UPDATE HERE LATER
            vis.checkHectares(layerCoords)
        });

        // Add empty layer groups for the hectare markers
        vis.geoHectareMarkers = L.geoJSON().addTo(vis.map);
    }

    checkHectares(layerCoords){
        let vis = this;

        // NOT OUR CODE; automatically generated by Browserify in order to use require("point-in-geopolygon") node package
        (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
            const inside = require("../node_modules/point-in-geopolygon/index")

        // reset to empty array
        vis.walkLatLngs = [];
        // reset to 0 walk distance
        vis.walkDistance = 0;

        // leaflet doubles the number of coordinates in walk path, hence i+2
        for(let i = 0; i<layerCoords.length; i = i+2){
            // apply array format for the coordinates
            vis.walkLatLngs.push([layerCoords[i].lng, layerCoords[i].lat])

            if(i>0){
                // calculate distance of walk using leaflet's distanceTo function
                vis.walkDistance += layerCoords[i].distanceTo(layerCoords[i - 1]);
            }
        }
        // console.log(vis.walkLatLngs)

        // reset to empty array
        vis.hectaresOnWalk = [];

        vis.walkLatLngs.forEach( (coordPair) => {
            // check which hectares the walk's coordinates are in ("inside" is a npm package function)
            let hectareFeature = inside.feature(vis.geoHectareData,coordPair)
            let hectareID = hectareFeature.properties["Hectare ID"]

            // check if hectareID is already in list (avoid repeat hectares in order to not double count squirrels)
            if(vis.hectaresOnWalk.indexOf(hectareID) === -1){
                // create list of hectare IDs for walk info
                vis.hectaresOnWalk.push(hectareID)
            }

        })
        // console.log(vis.hectaresOnWalk)

            // NOT OUR CODE; automatically generated by Browserify in order to use require("point-in-geopolygon") node package
            },{"../node_modules/point-in-geopolygon/index":2}],2:[function(require,module,exports){
                function scalar(x,y){return (x[0]*y[0]+x[1]*y[1]);}
                function det(x,y){return (x[0]*y[1]-x[1]*y[0]);}
                function circular(l,i){if((i>0)&&(i<=l-2)){return ([i-1,i+1]);}else if(i==0){return ([l-2,1]);}else if(i==l-1){return ([l-2,1]);}}
                function unit(v){var sr=Math.sqrt(scalar(v,v));return ([v[0]/sr , v[1]/sr]);}
                function vector(x,y){return ([y[0]-x[0],y[1]-x[1]]);}
                function sum(a,b){return([a[0]+b[0],a[1]+b[1]]);}
                function vct_max(jad,point,p,saver){
                    var s;
                    var tsd=scalar(vector(point,p),vector(point,p));
                    saver[0]=vector(jad[0][0],jad[0][1]);
                    var masafa=scalar(saver[0],saver[0]);
                    var pid=1;
                    var vs=[0,0];
                    for (var i = 1; i < jad[0].length-1; i++){
                        vs=sum(vs,saver[i-1]);
                        saver[saver.length]=vector(jad[0][i],jad[0][i+1]);
                        s=scalar(vs,vs);
                        if(s>masafa){pid=i;masafa=s;}}
                    if(tsd<=masafa){return pid;}
                    else{return -1;}}
                function filter(jad,point,p,saver){
                    var b;
                    var s;
                    var tsd=scalar(vector(point,p),vector(point,jad[0][1]));
                    saver[0]=vector(jad[0][0],jad[0][1]);
                    var masafa=scalar(saver[0],saver[0]);
                    var vs=[0,0];
                    for (var i = 1; i < jad[0].length-1; i++){
                        vs=sum(vs,saver[i-1]);
                        saver[saver.length]=vector(jad[0][i],jad[0][i+1]);
                        s=scalar(vector(point,p),unit(vs));
                        if(s>tsd){tsd=s;if(scalar(vector(point,p),vs)<=scalar(vs,vs)){b=true;}else{b=false;}}}
                    return b;}
                function distance(jad,p){var v=vector(jad,p); return scalar(v,v);}
                function sort_feacher(GeoJSON,p){
                    var sorted=new Array();
                    for (var i = 0; i < GeoJSON.features.length; i++) {
                        if(GeoJSON.features[i].geometry.type=='Polygon'){
                            sorted[i]={distance:distance(GeoJSON.features[i].geometry.coordinates[0][0],p),id:i};
                        }else{
                            sorted[i]={distance:distance(GeoJSON.features[i].geometry.coordinates[0][0][0],p),id:i};
                        }
                    }
                    return sorted.sort(function(a,b){return (a.distance - b.distance);});
                }
                function normal_ref_vector(jad,mix){
                    var n=unit(vector(jad[0][mix],jad[0][circular(jad[0].length,mix)[1]]));
                    if(scalar([n[1],-n[0]],vector(jad[0][mix],jad[0][circular(jad[0].length,mix)[0]]))<=0)
                    {return([n[1],-n[0]]);}else{return ([-n[1],n[0]]);}}
                function normal(v){return [-v[1],v[0]];}
                function delation(v,k){return[v[0]*k,v[1]*k]}
                function normal_vector(jad,i,mx,mix){
                    var d=vector(jad[0][mix],jad[0][circular(jad[0].length,mix)[1]]);
                    var f=vector(jad[0][i],jad[0][circular(jad[0].length,i)[1]]);
                    var cosine=scalar(d,f);
                    var sine=det(d,f);
                    var r=[(mx[0]*cosine-mx[1]*sine),(mx[0]*sine+mx[1]*cosine)];
                    return r;}
                function normalv(jad,i,mx,mix){
                    var cosine=scalar(unit(mix),unit(i));
                    var sine=det(unit(mix),unit(i));
                    return([(mx[0]*cosine-mx[1]*sine),(mx[0]*sine+mx[1]*cosine)]);}
                function sort_vector(jad,p,saver){
                    var srt=new Array();
                    var v=new Array();
                    var d=new Array();
                    var viv;
                    var bln=true;
                    var u=1000000;
                    srt[0]=[u,-1];
                    for (var i = 0; i < jad[0].length-1; i++){
                        d=saver[i];
                        v=vector(jad[0][i],p);
                        if(scalar(v,d)>=0){
                            var ti=(new Date()).getTime();
                            if(scalar(v,d)<=scalar(d,d)){
                                var f=det(v,unit(d));
                                if(Math.pow(f,2)<=srt[0][0]){
                                    srt[0][0]=Math.pow(f, 2);
                                    srt[0][1]=i;}
                                bln=false;}else{bln=true;}}else{if(bln){if(scalar(v,v)<=u){u=scalar(v,v);viv=i;}}}}
                    srt[1]=new Array();
                    srt[1][0]=u;
                    srt[1][1]=viv;
                    return srt;}
                module.exports=
                    {
                        polygon:function(jad,p){
                            var intern=false;
                            var saver=new Array();
                            var threshold=vct_max(jad,jad[0][0],p,saver);
                            if(threshold!=-1){
                                var mx=normal_ref_vector(jad,threshold);
                                var ti=(new Date()).getTime();
                                var tbs=sort_vector(jad,p,saver);
                                if(tbs[0][0]<=tbs[1][0]){
                                    if(tbs[0][0]<=tbs[1][0]){
                                        if(scalar(normal_vector(jad,tbs[0][1],mx,threshold),vector(jad[0][tbs[0][1]],p))<=0){intern=true;}}}
                                else{
                                    var v=vector(jad[0][tbs[1][1]],p);
                                    if(Math.abs(det(v,unit(saver[tbs[1][1]])))>Math.abs(det(v,unit(saver[((tbs[1][1]>0) ? tbs[1][1]-1 :saver.length-1)])))){
                                        if(scalar(normal_vector(jad,tbs[1][1],mx,threshold),v)<=0){intern=true;}}
                                    else{
                                        if(scalar(normal_vector(jad,circular(jad[0].length,tbs[1][1])[0],mx,threshold),v)<=0){
                                            intern=true;}}}}
                            return intern;}
                        ,
                        feature:function(GeoJSON,p){
                            var a;
                            var sort=sort_feacher(GeoJSON,p);
                            for (var i = 0; i < sort.length; i++) {
                                if(GeoJSON.features[sort[i].id].geometry.type=='Polygon'){
                                    if(this.polygon(GeoJSON.features[sort[i].id].geometry.coordinates,p)){
                                        a={
                                            id:sort[i].id,
                                            properties:GeoJSON.features[sort[i].id].properties,
                                            type:'Polygon'
                                        };
                                        break;
                                    }
                                }else{
                                    for (var j = 0; j < GeoJSON.features[sort[i].id].geometry.coordinates.length; j++){
                                        if(this.polygon(GeoJSON.features[sort[i].id].geometry.coordinates[j],p)){
                                            a={
                                                id:sort[i].id,
                                                properties:GeoJSON.features[sort[i].id].properties,
                                                type:'MultiPolygon',
                                                polygon:j
                                            };
                                            break;
                                        }
                                    }
                                    if(a){break;}
                                }
                            }
                            if(a){return a;}else{return -1;}
                        }
                    };
            },{}]},{},[1]);

        vis.updateVis()
    }

    updateVis() {
        let vis  = this;

        let numSquirrels = 0;
        let squirrelApproach = false;
        let otherAnimalsList = [];

        vis.hectaresOnWalk.forEach((walkHectare) => {
            vis.squirrelDataByHectare.forEach((squirrelHectare) => {
                if(walkHectare === squirrelHectare.key){
                    // sum of squirrels possible to see per hectare
                    numSquirrels += squirrelHectare.squirrelsInHectare
                    // if a squirrel could approach in one of the hectares, set true
                    if(squirrelHectare.squirrelWouldApproach){
                        squirrelApproach = true;
                    }
                }
            })

            // find what other animals possible to be viewed on walk
            vis.hectareData.forEach((hectareInfo) => {
                if(walkHectare === hectareInfo["Hectare"]){
                    // put string in array using .split(", ")
                    let hectareAnimals = hectareInfo["Other Animal Sightings"].split(", ")
                    hectareAnimals.forEach((animal) => {
                        // check for repeat animals and empty strings
                        if(otherAnimalsList.indexOf(animal) === -1 && animal !== ""){
                            // add new strings to array
                            otherAnimalsList.push(animal)
                        }
                    })
                }
            })
        })

        // turn array of animal strings into one large string
        let otherAnimals = otherAnimalsList.join(", ")

        let approachString = ""
        squirrelApproach ? approachString = " Yes!" : approachString = " No :("

        // convert distance to miles
        vis.walkDistance = vis.walkDistance*0.000621371192

        // don't forget walk distance
        d3.select("p.numSquirrels").text("Max Number of Squirrels You May See: " + numSquirrels)
        d3.select("p.walkDistance").text("Walking Distance: " + vis.walkDistance.toFixed(2) + " miles")
        d3.select("p.otherAnimals").text("Other Animals You Might See: " + otherAnimals)
        d3.select("p.squirrelApproach").text("Would a Squirrel Approach You?" + approachString)

    }

    initHeatMap(){
        let vis = this;

        // create category scale for y axis
        vis.squirrelScale = d3.scaleLinear()
            .domain([vis.squirrelMin,vis.squirrelMax])
            .range([0,1]);

        // Add empty layer groups for the hectare markers
        vis.geoHectareMarkers = L.geoJSON().addTo(vis.map);

        // function to bind pop up to each GEOJson hectare
        function onEachHectare(feature, layer){
            let squirrelsInHectare;

            // check if squirrelsInHectare is undefined
            if(!feature.properties.squirrelsInHectare){
                squirrelsInHectare = 0
            }
            else{
                squirrelsInHectare = feature.properties.squirrelsInHectare
            }

            layer.bindPopup("<div class=marker> <strong>Hectare ID: </strong>" + feature.properties["Hectare ID"] +
                "</br><strong>Squirrels in Hectare: </strong>" + squirrelsInHectare + "</div>")
        }

        // checking if squirrelsInHectare in undefined, if so set default to 0
        function setOpacity(numSquirrels){
            if(numSquirrels){
                return vis.squirrelScale(numSquirrels)
            }
            else{
                return vis.squirrelScale(0)
            }
        }

        vis.geoHectareData.features.forEach(feature => {
            // draw each hectare
            L.geoJson(feature, {
                color: "green",
                weight: 1,
                fillOpacity: setOpacity(feature.properties.squirrelsInHectare),
                onEachFeature: onEachHectare
            }).addTo(vis.geoHectareMarkers)
        })
    }

    clearHeatMap() {
        let vis = this;

        // clear markers from previous rendering of layers
        vis.geoHectareMarkers.clearLayers()
    }

}

